[{"uri":"https://csbiology.github.io/ProteomIQon/index.html","title":"index","content":"(**\n[![Made with F#](https://img.shields.io/badge/Made%20with-FSharp-rgb(184,69,252).svg)](https://fsharp.org/)\n![GitHub contributors](https://img.shields.io/github/contributors/CSBiology/ProteomIQon)\n\nThe ProteomIQon \n----------------------\n\nThe ProteomIQon is a collection of open source computational proteomics tools to build pipelines for the evaluation of MS derived proteomics data\nwritten in F#. The current state of the tool chain allows handle tasks like signal detection, peptide identification, quantification and protein inference.\n\n\u003Cimg src=\u0022{{root}}img/PillarsOfCompProt.png\u0022 width=\u00221000\u0022 height=\u0022750\u0022 /\u003E\n\nEach ProteomIQon tool is concerned with a specific task. This makes the tool-chain flexibel and easily extendable. \nAn example of a prototypical chaining of tools to identify and quantify a mix of 14N and 15N labeled proteins can be found in the [here]().\nWe are currently working on the [cwl tool and workflow descriptions](https://github.com/common-workflow-language), so you can expect a to see more workflow graphs in the near future!\n   \nAll tools are available using [nuget](https://www.nuget.org/profiles/CSBiology) and soon via BioConda. \nEach tool is described in detail on its corresponding documentation page, accessible via the navigation pane, if you think a functionality is missing, feel free to contact us or to join us as a contributor!\n\n\nThe Core Project\n------------------\n\nThe ProteomIQon core is referenced by all tools. It contains mainly serializable data transfer objects such as tool results and tool parameters, as well as their mapping to domain specific types. \nThis is also the place for any kind of code reusable across tools such as thin wrappers around data readers, logging or CLI formatting. \n\nDocumentation\n-------------\n\nThe documentation and tutorials for this library are automatically generated (using the F# Formatting) from .fsx and .md files in the docs folder. If you find a typo, please submit a pull request!\n\nContributing\n------------\n\nPlease refer to the CSB [Contribution guidelines](https://github.com/CSBiology/BioFSharp/blob/developer/.github/CONTRIBUTING.md)\n\nCommunity/Social\n----------------\nWant to get in touch with us? We recently joined the twitter crowd:\n\n[![Twitter Follow](https://img.shields.io/twitter/follow/cs_biology.svg?style=social)](https://twitter.com/cs_biology)\n*)"},{"uri":"https://csbiology.github.io/ProteomIQon/develop/How_to_document_your_work.html","title":"How to document your work","content":"(**\n---\ntitle: How to document your work\ncategory: Developer Notes\ncategoryindex: 2\nindex: 2\n---\n*)\n(**\n# How to document your work\n**Disclaimer** This page gives only an overview of the FSharp.Formatting functionality needed to contribute to the ProteomIQon, for details please visit \nthe documentation of [FSharp.Formatting](https://fsprojects.github.io/FSharp.Formatting/).\n\nThe web page that you are just reading was created using the [fsdocs](https://fsprojects.github.io/FSharp.Formatting/commandline.html) dotnet tool!\nThanks to the effort of the FSharp.Formatting team documenting the ProteomIQon is a straightforward process.\n\n## Building the docs:\nAssuming that you have cloned the ProteomIQon repository you can build the docs by navigating to the project root and calling: \n*)\n\n(**\n\tdotnet fsdocs watch --eval --noapidocs\n*)\n\n(**\nExecuting this command will lead to parsing of all .fsx files in the docs folder, this will finally lead to formatting of every .fsx as a html documents and notebooks.\nThis is all done behind the scenes orchestrated by the fsdocs cli tool. Once this process is finished your default browser should start and automatically navigate to \nthe adress of the index.html hosted on a local webserver.\n*)\n\n(**\n## How to change exisiting content:\nThe fsdocs tool enables you to manipulate the docs and immediately observe the effects of your actions. To try out the hot reload functionality simply change the content of a \nfsx file placed in the ./docs folder of the proteomiqon repository and save your changes. After a short while, this should trigger a reload in you webbrowser and you should be able to \nsee an updated .html file with your changes incorporated.\n\n## How to add a tool documentation:\nIf you are working on your own tool, chances are high that you want to add a new .html to the docs. A suggested workflow to add a docs page for your tool could look like this:\n\n1. Navigate to ./docs/tools\n2. Copy one of the existing .fsx files and rename it\n3. Replace the content with the content fitting to your tool.\n\n## Update the online documentation:\nOnce you are happy with your contribution simply open a pull request. Upon acceptance of your commit, a github action is triggered and the new version of the docs are automatically released.\n*)\n"},{"uri":"https://csbiology.github.io/ProteomIQon/develop/How_to_create_a_tool.html","title":"How to create your own tool","content":"(**\n---\ntitle: How to create your own tool\ncategory: Developer Notes\ncategoryindex: 2\nindex: 1\n---\n*)\n(**\n# How to create a tool\n\nIf you want to extend the functionality of the ProteomIQon you can either submit a pull request to update\nan existing tool or - if the functionality is better encapsulated as a stand alone application - create a new tool.\nTo make this as as easy as possible we created a tool template which sets up a basic scaffold for your new tool!\n\n## Installing the template:\nAssuming that you have cloned the ProteomIQon repository you can install the tool by navigating to the project root and calling: \n*)\n\n(**\n\tdotnet new --install ./ConsoleTemplate/template\n*)\n\n(**\nThe installation can then be verified by executing the following snippet:\n*)\n\n(**\n\tdotnet new --list \n*)\n\n(**\nThis should print a list of installed templates. If everything was successful you will find the line among the installed tools: \n*)\n\n(**\n\tTemplates                           Short Name               Language          Tags\n\t------------------------------      -------------------      ------------      ----------------------------------------\n\t...\n\tprototypical proteomiqon co...      pct                      F#                proteomiqon console/proteomiqon/template\n\t...\n*)\n\n(**\n## Adding a new tool to the project:\nTo initialize a new tool using the template, navigate into the \u0027src\u0027 folder, replace \u0027projectName\u0027 with your choice for a tool name and call:\n*)\n\n(**\n\tdotnet new pct -n \u0022projectName\u0022 --force\n*)\n\n(**\nAfterwards navigate back to the project root and execute the following line to add your tool to the ProteomIQon solution:\n*)\n\n(**\n\tdotnet sln ProteomIQon.sln add \u0022./src/projectName/projectName.fsproj\u0022\n*)\n\n(**\nAfterwards you should be good to go! Have fun extending the ProteomIQon, we look forward to your contribution!\n*)"},{"uri":"https://csbiology.github.io/ProteomIQon/develop/How_to_build_binaries_or_packages.html","title":"How to build binaries or packages","content":"(**\n---\ntitle: How to build binaries or packages\ncategory: Developer Notes\ncategoryindex: 2\nindex: 3\n---\n*)\n(**\n# How to build the binaries\n\nIf you want to build the binaries for all tools at one, you can simply navigate to the project root in the console and call:\n\n\tbuild.cmd\n\nIf you want to build only a singe project, then you can use the \u0022BuildProj\u0022 target like this:\n\n\tbuild.cmd -t BuildProj\n\nAfter the \u0022Clean\u0022 target you will then be prompted to enter the name of the project you wish to build.\n\n# How to pack a nuget package\n\nIf you want to pack a nuget package or build a dotnet tool, you can do this for all tools at once by invoking the \u0022Pack\u0022 or \u0022PackPrerelease\u0022 target.\n\n\tbuild.cmd -t Pack\n\nPacking only a single project works similar to the same case for the binaries. The targets for this are calles \u0022PackProj\u0022 and \u0022PackPrereleaseProj\u0022:\n\n\tbuild.cmd -t PackProj\n\nAfter the \u0022Clean\u0022 target you will then be prompted to enter the name of the project you wish to build.\n*)"},{"uri":"https://csbiology.github.io/ProteomIQon/tools/MzMLToMzLite.html","title":"MzMLToMzLite","content":"(**\n---\ntitle: MzMLToMzLite\ncategory: Tools\ncategoryindex: 1\nindex: 1\n---\n*)\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/ProteomIQon/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n# mzMl to mzlite Conversion\n**Disclaimer** this tool converts [mzML](https://www.psidev.info/mzML) to [mzLite](https://github.com/CSBiology/MzIO/blob/developer/src/MzIO.SQL/MzIOSQL.fs) \nif you want to convert the other way around please visit the [MzLiteToMzML]({{root}}tools/MzLiteToMzML.html) documentation. \nWe recommend the use of [msconvert](https://www.nature.com/articles/nbt.2377) to convert your raw data into .mzML. \nA user friendly way to execute msconvert is available through [Galaxy Europe](https://galaxyproject.eu/posts/2019/03/24/msconvert/).\n\nThe success of modern proteomics was made possible by constant progression in the field of mass spectrometry. Over the course of the past years quite a few\nmanufacturers of mass spectrometers have managed to establish themselfes in the field of biological research. Since aquisition and accession of mass spectra are performance critical processes, \nvarious performance optimized, but vendor specific and closed source formats have been developed to store raw MS data. \nThis comes to the disadvantage for toolchain developers which want to provide tools for every scientist regardless of the format of their raw data.    \n\nIn a effort to provide an open format for the storage of MS data the format [mzML](https://www.psidev.info/mzML) was developed. While this XML based format is straight forward to implement\nit falls behind in performance critical scenarios. To be competitive in performance and to comply to the [FAIR principles](https://www.go-fair.org/fair-principles/) we chose\nto use [mzLite](https://github.com/CSBiology/MzIO/blob/developer/src/MzIO.SQL/MzIOSQL.fs), an open and SQLite based implementation of mzML, within our toolchain.\n\nThe tool mzMLToMzLite allows to convert mzML files to mzLite files. Additionally, it allows the user to perform peak picking or filtering of mass spectra.\n\n## Parameters\nThe following table gives an overview of the parameter set:\n\n| **Parameter**                  | **Default Value**                                                                                                                         | **Description**                                                    |\n|--------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|\n| Compress                       | MzIO.Binary.BinaryDataCompressionType.NoCompression                                                                                       | Indicates if peak data should be compressed                        |\n| StartRetentionTime             | None                                                                                                                                      | Minimum scan time for spectra to be copied                         |\n| EndRetentionTime               | None                                                                                                                                      | Maximum scan time for spectra to be copied                         |\n| MS1PeakPicking                 | PeakPicking.ProfilePeaks                                                                                                                  | Parameter to configure peak picking                                |\n| MS2PeakPicking                 | PeakPicking.ProfilePeaks                                                                                                                  | Parameter to configure peak picking                                |\n\n## Parameter Generation\n\nParameters are handed to the cli tool as a .json file. you can download the default file [here](https://github.com/CSBiology/ProteomIQon/blob/master/src/ProteomIQon/defaultParams/mzMLToMzLiteParams.json), \nor use an F# script, which can be downloaded or run in Binder at the top of the page, to write your own parameter file:\n*)\n\n#r \u0022nuget: ProteomIQon, 0.0.5\u0022\n\nopen ProteomIQon\nopen ProteomIQon.Domain\n\nlet defaultMzMLToMzLiteParams :Dto.MzMLtoMzLiteParams =   \n    {\n        Compress                    = MzIO.Binary.BinaryDataCompressionType.NoCompression\n        StartRetentionTime          = None\n        EndRetentionTime            = None\n        MS1PeakPicking = PeakPicking.ProfilePeaks\n        MS2PeakPicking = PeakPicking.ProfilePeaks \n    }\n\n\nlet serialized = \n    defaultMzMLToMzLiteParams\n    |\u003E Json.serialize\n\n(***condition:ipynb***)\n#if IPYNB\n(**\nIf you are running this tool in Binder, you can copy the output of the following codeblock and save it in a JSON file.\n*)\nserialized\n#endif // IPYNB\n\n(**\n## Executing the Tool\n**Disclaimer** this tool converts [mzML](https://www.psidev.info/mzML) to [mzLite](https://github.com/CSBiology/MzIO/blob/developer/src/MzIO.SQL/MzIOSQL.fs) \nif you want to convert the other way around please visit the [MzLiteToMzML]({{root}}tools/MzLiteToMzML.html) documentation. \nWe recommend the use of [msconvert](https://www.nature.com/articles/nbt.2377) to convert your raw data into .mzML. \nA user friendly way to execute msconvert is available through [Galaxy Europe](https://galaxyproject.eu/posts/2019/03/24/msconvert/).\n\nTo convert a mzML file to mzLite call: \n\n*)\n\n(**\n\tproteomiqon-mzmltomzlite -i \u0022path/to/your/run.mzML\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022\n*)\n\n(**\nIt is also possible to call the tool on a list of .mzML files. If you have a mulitcore cpu it is possible to convert multiple runs in parallel using the -c flag:\n*)\n\n(**\n\tproteomiqon-mzmltomzlite -i \u0022path/to/your/run1.mzML\u0022 \u0022path/to/your/run2.mzML\u0022 \u0022path/to/your/run3.mzML\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022 -c 3\n*)\n\n(**\nA detailed description of the CLI arguments the tool expects can be obtained by calling the tool:\n*)\n\n(**\n\tproteomiqon-mzmltomzlite --help\n*)\n"},{"uri":"https://csbiology.github.io/ProteomIQon/tools/PSMBasedQuantification.html","title":"PSMBasedQuantification","content":"(**\n---\ntitle: PSMBasedQuantification\ncategory: Tools\ncategoryindex: 1\nindex: 6\n---\n*)\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/ProteomIQon/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n# Peptide Spectrum Matching based Quantification\n**Disclaimer** this tool needs a [peptide database]({{root}}tools/peptideDb.html) and [peptide spectrum matches]({{root}}tools/PeptideSpectrumMatching.html)\nwhich [passed fdr thresholds]({{root}}tools/PSMStatistics.html).\n\nOnce a MS/MS spectrum is mapped to a peptide sequence the quantity of the fragmented peptide ion comes into view. \n\nGiven an MS run in the mzLite or mzml format and a list of [fdr controlled peptide spectrum matches]({{root}}tools/PSMStatistics.html), \nthis tool iterates accross all identified MS/MS scans and groups them by the assigned peptide ion. The scan times of each MS/MS spectrum \nare then weighted according to the quality of each match to build an reliable estimator for the scan time of the peptide ion in question.\nThis scan time estimator, combined with the monoisotopic m/z, is then used to extract an ion chromatogram. Using wavelet based peak detection techniques we identify\nall peaks present in the XIC and select the most probable peak our target for quantification. Using parameter estimation techniques we subsequently use peak fitting\nto fit a set of two gaussian models to the detected peak, from whom the one with the better fit is selected. This allows us not only to report how well the\nsignal fitted to the theoretical expected peak shape but also to obtain accurate estimates for the peak area, our estimator for peptide ion abundance.\n\n\u003Cimg src=\u0022{{root}}img/LabeledQuant.png\u0022 width=\u00221000\u0022 height=\u0022750\u0022 /\u003E\n\nThe quantification tool was designed to allow label-free quantification as well as quantification of full metabolic labeled samples. For this we \nuse the known identity of one of the the peptide ions and calculate the m/z of the unobserved differentially labeled counterpart to extract and \nquantify the corresponding XIC. \n\n## Parameters\nThe following table gives an overview of the parameter set:\n\n| **Parameter**                  | **Default Value**                                                                                                                         | **Description**                                                    |\n|--------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|\n| PerformLabeledQuantification   | true                                                                                                                                      | Indicates if a labeled quantification should be performed          |\n| XicExtraction                  | {TopKPSMs = None; ScanTimeWindow = 2.; MzWindow_Da = 0.07; XicProcessing = Wavelet waveletParams}                                         | Parameters to tune the Xic extraction                              |\n| BaseLineCorrection             | Some { MaxIterations = 10; Lambda = 6; P = 0.05 }                                                                                         | optional parameter, defines if and how baseline correction should be performed |\n\n        \n## Parameter Generation\n\nParameters are handed to the cli tool as a .json file. you can download the default file [here](https://github.com/CSBiology/ProteomIQon/blob/master/src/ProteomIQon/defaultParams/peptideSpectrumMatchingParams.json), \nor use an F# script, which can be downloaded or run in Binder at the top of the page, to write your own parameter file:\n*)\n\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n#r \u0022nuget: ProteomIQon, 0.0.1\u0022\n\nopen ProteomIQon\nopen ProteomIQon.Domain\nopen FSharp.Stats.Signal\n\nopen BioFSharp.Mz\n\nlet defaultQuantificationParams :Dto.QuantificationParams = \n    ///\n    let waveletParams :WaveletParameters = \n        {\n            Borderpadding           = None    \n            BorderPadMethod         = Padding.BorderPaddingMethod.Random \n            InternalPaddingMethod   = Padding.InternalPaddingMethod.LinearInterpolation \n            HugeGapPaddingMethod    = Padding.HugeGapPaddingMethod.Zero\n            HugeGapPaddingDistance  = 100.\n            MinPeakDistance         = None\n            MinPeakLength           = Some 0.1\n            MaxPeakLength           = 1.5 \n            NoiseQuantile           = 0.01 \n            MinSNR                  = 0.01  \n        }\n\n    let XicExtraction = \n        {\n            TopKPSMs                     = None\n            ScanTimeWindow               = 2.\n            MzWindow_Da                  = 0.07 \n            XicProcessing                = Wavelet waveletParams\n        }\n\n    let BaseLineCorrection = \n        {\n            MaxIterations                = 10 \n            Lambda                       = 6 \n            P                            = 0.05\n        }\n    {\n        PerformLabeledQuantification = true\n        XicExtraction                = XicExtraction\n        BaseLineCorrection           = Some BaseLineCorrection\n    }\n\n\nlet serialized = \n    defaultQuantificationParams\n    |\u003E Json.serialize\n\n(***condition:ipynb***)\n#if IPYNB\n(**\nIf you are running this tool in Binder, you can copy the output of the following codeblock and save it in a JSON file.\n*)\nserialized\n#endif // IPYNB\n\n(**\n## Executing the Tool\n**Disclaimer** this tool needs a [peptide database]({{root}}tools/peptideDb.html) and [peptide spectrum matches]({{root}}tools/PeptideSpectrumMatching.html)\nwhich [passed fdr thresholds]({{root}}tools/PSMStatistics.html).\n\n*)\n\n(**\n\tproteomiqon-psmbasedquantification -i \u0022path/to/your/run.mzlite\u0022 -ii \u0022path/to/your/run.qpsm\u0022 -d \u0022path/to/your/database.sqlite\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022\n*)\n\n(**\nIt is also possible to call the tool on a lists of MS and scored psm files. If you have a mulitcore cpu it is possible to score multiple runs in parallel using the -c flag:\n*)\n\n(**\n\tproteomiqon-psmbasedquantification -i \u0022path/to/your/run1.mzlite\u0022 \u0022path/to/your/run2.mzlite\u0022 \u0022path/to/your/run3.mzlite\u0022 -ii \u0022path/to/your/run1.qpsm\u0022 \u0022path/to/your/run2.qpsm\u0022 \u0022path/to/your/run3.qpsm\u0022 -d \u0022path/to/your/database.sqlite\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022 -c 3\n*)\n\n(**\nBy default, mzlite and qpsm files get matched by their position in the list. To perform a name based file match set the -mf flag:\n*)\n\n(**\n\tproteomiqon-psmbasedquantification -i \u0022path/to/your/run1.mzlite\u0022 \u0022path/to/your/run3.mzlite\u0022 \u0022path/to/your/run2.mzlite\u0022 -ii \u0022path/to/your/run1.qpsm\u0022 \u0022path/to/your/run2.qpsm\u0022 \u0022path/to/your/run3.qpsm\u0022 -d \u0022path/to/your/database.sqlite\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022 -c 3 -mf \n*)\n\n(**\nA detailed description of the CLI arguments the tool expects can be obtained by calling the tool:\n*)\n\n(**\n\tproteomiqon-psmbasedquantification --help\n*)"},{"uri":"https://csbiology.github.io/ProteomIQon/tools/ProteinInference.html","title":"ProteinInference","content":"(**\n---\ntitle: ProteinInference\ncategory: Tools\ncategoryindex: 1\nindex: 7\n---\n*)\n\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/ProteomIQon/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n# Protein Inference\n**Disclaimer** this tool needs a [peptide database]({{root}}tools/peptideDb.html) and [peptide spectrum matches]({{root}}tools/PeptideSpectrumMatching.html)\nwhich [passed fdr thresholds]({{root}}tools/PSMStatistics.html).\n\nMS-based shotgun proteomics estimates protein abundances using a proxy: peptides. The process of \u0027Protein Inference\u0027 is concerned with the mapping of identified peptides\nto the proteins they putatively originated from. This process is not as straightforward as one might think at a first glance on the subject, since the peptide-to-protein mapping\nis not necessarily a one-to-one relationship but in many cases a one-to-many relationship. This is due to the fact that many proteins share peptides with an identical sequence, e.g.\ntwo proteins originating from two different splice variants of the same gene.\n\nOne way to cope with this problem is to introduce the concept of protein groups, which allow us to report the aggregation of all peptides which map to all isoforms of a gene\nindependently from the peptides mapping uniquely to a single isoform. While this approach has its merits it leaves room for fine tuning when implemented. Lets say we have two proteins pA and pB which were both\ndiscovered by one peptide uniquely mapping to each of them and additionally by a third peptide, which maps to both of them: How do we report our findings?\nWe could report both proteins seperately and as a protein group, we could only report the protein group, or we could report both proteins but not the protein group. A problem of comparable complexity occurs when\nwe think about peptides when calculating the abundances for the proteingroup pA;pB. Do we use the peptides only once, or do we also use the peptides mapping uniquely to protein pA and pB? \nFortunately, the tool ProteinInference gives you the possibility to choose any of the described scenarios by tuning the parameters described below. \nThe following scheme gives an overview how parameter settings influence inferred protein groups:\n\n\u003Cimg src=\u0022{{root}}img/ProteinInference.png\u0022 width=\u00221200\u0022 height=\u00221000\u0022 /\u003E\n\nMoreover, we report each protein group with a so called \u0027Peptide evidence class\u0027. This metric gives an indication how pure the peptide composition of a protein group is and\nlets us differentiate between protein groups that consist of isoforms of a splice variant or contain a rather arbitrary mix of proteins. In order to determine these inter-protein relationships the\nuser can optionally supply a gff3 file.\n\n## Parameters\nThe following table gives an overview of the parameter set:\n\n| **Parameter**                  | **Default Value**                                                                                                                         | **Description**                                                    |\n|--------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|\n| ProteinIdentifierRegex         | id                                                                                                                                        | Regex pattern for parsing of the protein IDs in the database       |\n| Protein                        | ProteinInference.IntegrationStrictness.Maximal                                                                                            | Parameter to tune creation of protein groups (see scheme above)    |\n| Peptide                        | ProteinInference.PeptideUsageForQuantification.Minimal                                                                                    | Parameters to tune the way peptides are aggregated (see scheme above) |\n| GroupFiles                     | true                                                                                                                                      | Indicates if information is shared accross .qpsm files             |\n| GetQValue                      | QValueMethod.Storey                                                                                                                       | Lets the user choose between published FDR calculation methods     |\n\n## Parameter Generation\n\nParameters are handed to the cli tool as a .json file. you can download the default file [here](https://github.com/CSBiology/ProteomIQon/blob/master/src/ProteomIQon/defaultParams/peptideSpectrumMatchingParams.json), \nor use an F# script, which can be downloaded or run in Binder at the top of the page, to write your own parameter file:\n*)\n\n#r \u0022nuget: ProteomIQon, 0.0.5\u0022\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n\nopen ProteomIQon\nopen ProteomIQon.Domain\nopen BioFSharp.Mz\n\nlet defaultProteinInferenceParams: Dto.ProteinInferenceParams =\n    {\n        ProteinIdentifierRegex = \u0022id\u0022\n        Protein                = ProteinInference.IntegrationStrictness.Maximal\n        Peptide                = ProteinInference.PeptideUsageForQuantification.Minimal\n        GroupFiles             = true\n        GetQValue              = QValueMethod.Storey \n    }\n\nlet serialized = \n    defaultProteinInferenceParams\n    |\u003E Json.serialize\n\n(***condition:ipynb***)\n#if IPYNB\n(**\nIf you are running this tool in Binder, you can copy the output of the following codeblock and save it in a JSON file.\n*)\nserialized\n#endif // IPYNB\n\n(**\n## Executing the Tool\n**Disclaimer** this tool needs a [peptide database]({{root}}tools/peptideDb.html) and [peptide spectrum matches]({{root}}tools/PeptideSpectrumMatching.html)\nwhich [passed fdr thresholds]({{root}}tools/PSMStatistics.html). \n\nTo map all identified peptide sequences of an MS run to a protein group simply call:\n\n*)\n\n(**\n\tproteomiqon-proteininference -i \u0022path/to/your/run.qpsm\u0022 -d \u0022path/to/your/database.sqlite\u0022 -g \u0022path/to/your/proteom.gff3\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022\n*)\n\n(**\nIt is also possible to call the tool on a lists of scored psm files:\n*)\n\n(**\n\tproteomiqon-proteininference -i \u0022path/to/your/run1.qpsm\u0022 \u0022path/to/your/run2.qpsm\u0022 \u0022path/to/your/run3.qpsm\u0022 -d \u0022path/to/your/database.sqlite\u0022 -g \u0022path/to/your/proteom.gff3\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022 \n*)\n\n(**\nA detailed description of the CLI arguments the tool expects can be obtained by calling the tool:\n*)\n\n(**\n\tproteomiqon-proteininference --help\n*)"},{"uri":"https://csbiology.github.io/ProteomIQon/tools/PeptideSpectrumMatching.html","title":"PeptideSpectrumMatching","content":"(**\n---\ntitle: PeptideSpectrumMatching\ncategory: Tools\ncategoryindex: 1\nindex: 4\n---\n*)\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/ProteomIQon/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n# Peptide Spectrum Matching\n**Disclaimer** this tool needs a peptide database to query against, if you did not create one yet you can do so by using the [PeptideDB]({{root}}tools/peptideDb.html) tool.\n\nAn established method to identify acquired MS/MS spectra is the comparison of each spectrum with peptides in a [reference database]({{root}}tools/peptideDb.html). \n\nGiven raw a MS run in the mzLite or mzml format, this tool iterates accross all recorded MS/MS scans and determines the charge state of precursor ions which were selected for fragmentation. With this it is possible to \nquery the peptide data base for every precursor ion mass \u002B/- a tolerance (which defines the so called \u0027search space\u0027) and retrieve peptides that are theoretical candidates for a match. \nFor each of the peptide candidates we create an theoretical spectrum in silico and compare it to the measured MS/MS scan. \n\n\u003Cimg src=\u0022{{root}}img/PSM.png\u0022 width=\u00221000\u0022 height=\u0022750\u0022 /\u003E\n\nTo measure similarity we use our own implementations of three established search enginge scores: SEQUEST, Andromeda and XTandem.\nThe search space is extended by so called decoys. Decoys are reversed counterparts of peptides within the search space and allow us to assign a false discovery rate to each scored peptide\nusing the [PSMStatistics tool]({{root}}tools/PSMStatistics.html).\n\n## Parameters\nThe following table gives an overview of the parameter set:\n\n| **Parameter**                  | **Default Value**                                                                                                                         | **Description**                                                    |\n|--------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|\n| ChargeStateDeterminationParams | {ExpectedMinimalCharge = 2; ExpectedMaximumCharge = 5; Width = 1.1; MinIntensity = 0.15; DeltaMinIntensity = 0.3; NrOfRndSpectra = 10000} | Parameters used for the charge state determination of the peptides |\n| LookUpPPM                      | 30                                                                                                                                        | Mass range in Da in which potential peptides are selected          |\n| MS2ScanRange                   | 100.,2000.                                                                                                                                | m/z range for MS2 spectra                                          |\n| nTerminalSeries                | NTerminalSeries.B                                                                                                                         | Considered ions starting from the N-Terminus                       |\n| cTerminalSeries                | CTerminalSeries.Y                                                                                                                         | Considered ions starting from the C-Terminus                       |\n| Andromeda                      | {PMinPMax = 4,10; MatchingIonTolerancePPM = 100.}                                                                                         | Andromeda scoring parameters                                       |\n\n## Parameter Generation\n\nParameters are handed to the cli tool as a .json file. you can download the default file [here](https://github.com/CSBiology/ProteomIQon/blob/master/src/ProteomIQon/defaultParams/peptideSpectrumMatchingParams.json), \nor use an F# script, which can be downloaded or run in Binder at the top of the page, to write your own parameter file:\n*)\n\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n#r \u0022nuget: Newtonsoft.Json, 12.0.3\u0022\n#r \u0022nuget: ProteomIQon, 0.0.5\u0022\n\nopen BioFSharp.Mz.SearchDB\nopen Newtonsoft.Json\nopen ProteomIQon\nopen ProteomIQon.Domain\nopen BioFSharp.Mz\n\nlet chargeDetermParams :ChargeState.ChargeDetermParams =\n    {\n        ExpectedMinimalCharge = 2\n        ExpectedMaximumCharge = 5\n        Width                 = 1.1\n        MinIntensity          = 0.15\n        DeltaMinIntensity     = 0.3\n        NrOfRndSpectra        = 10000\n    }\n\nlet andromedaParams: AndromedaParams =\n    {\n        PMinPMax                = 4,10\n        MatchingIonTolerancePPM = 100.\n    }\n\nlet peptideSpectrumMatchingParams :Dto.PeptideSpectrumMatchingParams =\n    {\n        ChargeStateDeterminationParams = chargeDetermParams \n        LookUpPPM                      = 30.\n        nTerminalSeries                = NTerminalSeries.B\n        cTerminalSeries                = CTerminalSeries.Y\n        Andromeda                      = andromedaParams\n    }\n\n\nlet serialized =\n    peptideSpectrumMatchingParams\n    |\u003E JsonConvert.SerializeObject\n\n(***condition:ipynb***)\n#if IPYNB\n(**\nIf you are running this tool in Binder, you can copy the output of the following codeblock and save it in a JSON file.\n*)\nserialized\n#endif // IPYNB\n\n(**\n## Executing the Tool\n**Disclaimer** this tool needs a peptide database to query against, if you did not create one yet you can do so by using the [PeptideDB]({{root}}tools/peptideDb.html) tool.\n\nTo score all MS/MS of an MS run simply call: \n\n*)\n\n(**\n\tproteomiqon-peptidespectrummatching -i \u0022path/to/your/run.mzml\u0022 -d \u0022path/to/your/database.sqlite\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022\n*)\n\n(**\nIt is also possible to call the tool on a list of MS files. If you have a mulitcore cpu it is possible to score multiple runs in parallel using the -c flag:\n*)\n\n(**\n\tproteomiqon-peptidespectrummatching -i \u0022path/to/your/run1.mzml\u0022 \u0022path/to/your/run2.mzml\u0022 \u0022path/to/your/run3.mzml\u0022 -d \u0022path/to/your/database.sqlite\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022 -c 3\n*)\n\n(**\nA detailed description of the CLI arguments the tool expects can be obtained by calling the tool:\n*)\n\n(**\n\tproteomiqon-peptidespectrummatching --help\n*)"},{"uri":"https://csbiology.github.io/ProteomIQon/tools/PSMStatistics.html","title":"PSMStatistics","content":"(**\n---\ntitle: PSMStatistics\ncategory: Tools\ncategoryindex: 1\nindex: 5\n---\n*)\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/ProteomIQon/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n# Peptide Spectrum Matching Statistics\n**Disclaimer** this tool relies on the output of the tools [PeptideDB]({{root}}tools/peptideDb.html) and [PeptideSpectrumMatching]({{root}}tools/PeptideSpectrumMatching.html).\n\nAn established method to identify acquired MS/MS spectra is the [comparison]({{root}}tools/PeptideSpectrumMatching.html) of each spectrum with peptides in a [reference database]({{root}}tools/peptideDb.html). \n\nTo measure the similarity of in silico generated spectra and measured MS/MS scans we use our own implementations of three established search enginge scores: SEQUEST, Andromeda and XTandem. \nAdditionally, we also record quality control parameters such as the mass difference between the precursor ion and the theoretically calulated mass or the uniquness of each score in comparison to \u0027competing\u0027\npeptides within the search space. The PSMStatistics tool utilizes semi supervised machine learning techniques to integrate search engine scores as well as the mentioned quality scores into one single consensus score. \n\n\u003Cimg src=\u0022{{root}}img/SemiSupervisedScoring.png\u0022 width=\u00221000\u0022 height=\u0022750\u0022 /\u003E\n\nSince the search space is extended by so called decoys - reversed counterparts of peptides within the search space - we can estimate the distribution of \u0027true negatives\u0027 and calculate local (PEP values) and global (Q values)\nfalse discovery rates at each consensus score. \nThe reported peptides at user defined local and global FDR cutoffs can then be used as inputs for any downstream analysis be it [ProteinInference]({{root}}tools/ProteinInference.html) or [PSMBasedQuantification]({{root}}tools/PSMBasedQuantification.html) \n\n## Parameters\nThe following table gives an overview of the parameter set:\n\n| **Parameter**                  | **Default Value**                                                                                                                         | **Description**                                                    |\n|--------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|\n| Threshold                      | Threshold.Estimate {QValueThreshold = 0.01; PepValueThreshold = 0.05; MaxIterations=15; MinimumIncreaseBetweenIterations=0.005 }          | Parameters used for FDR based filtering of scored peptides         |\n| ParseProteinIDRegexPattern     | id                                                                                                                                        | Regex pattern for parsing of the protein IDs in the database       |\n| KeepTemporaryFiles             | false                                                                                                                                     | Indicates if temporary files should be kept or discarded           |\n\n## Parameter Generation\n\nParameters are handed to the cli tool as a .json file. you can download the default file [here](https://github.com/CSBiology/ProteomIQon/blob/master/src/ProteomIQon/defaultParams/psmstatisticsparams.json), \nor use an F# script, which can be downloaded or run in Binder at the top of the page, to write your own parameter file:\n*)\n\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n#r \u0022nuget: ProteomIQon, 0.0.1\u0022\n\nopen ProteomIQon\nopen ProteomIQon.Domain\nopen BioFSharp.Mz\n\n\nlet defaultPSMStatistics : Dto.PSMStatisticsParams = \n    {\n        Threshold = Threshold.Estimate {QValueThreshold = 0.01; PepValueThreshold = 0.05;MaxIterations=15;MinimumIncreaseBetweenIterations=0.005}\n        ParseProteinIDRegexPattern  = \u0022id\u0022\n        KeepTemporaryFiles          = true\n    }\n\nlet serialized = \n    defaultPSMStatistics\n    |\u003E Json.serialize\n\n(***condition:ipynb***)\n#if IPYNB\n(**\nIf you are running this tool in Binder, you can copy the output of the following codeblock and save it in a JSON file.\n*)\nserialized\n#endif // IPYNB\n\n(**\n## Executing the Tool\n**Disclaimer** this tool relies on the output of the tools [PeptideDB]({{root}}tools/peptideDb.html) and [PeptideSpectrumMatching]({{root}}tools/PeptideSpectrumMatching.html).\n\nTo rescore all MS/MS to identify \u0027true\u0027 psms call: \n\n*)\n\n(**\n\tproteomiqon-psmstatistics -i \u0022path/to/your/run.psm\u0022 -d \u0022path/to/your/database.sqlite\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022\n*)\n\n(**\nIt is also possible to call the tool on a list of .psm files. If you have a mulitcore cpu it is possible to rescore multiple runs in parallel using the -c flag:\n*)\n\n(**\n\tproteomiqon-psmstatistics -i \u0022path/to/your/run1.psm\u0022 \u0022path/to/your/run2.psm\u0022 \u0022path/to/your/run3.psm\u0022 -d \u0022path/to/your/database.sqlite\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022 -c 3\n*)\n\n(**\nTo create diagnostic plots which show the performance of the psm scorer after a iteration, you can specify the -dc flag:\n*)\n\n(**\n\tproteomiqon-psmstatistics -i \u0022path/to/your/run1.psm\u0022 \u0022path/to/your/run2.psm\u0022 \u0022path/to/your/run3.psm\u0022 -d \u0022path/to/your/database.sqlite\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022 -c 3 -dc\n*)\n\n(**\nA detailed description of the CLI arguments the tool expects can be obtained by calling the tool:\n*)\n\n(**\n\tproteomiqon-psmstatistics --help\n*)\n"},{"uri":"https://csbiology.github.io/ProteomIQon/tools/PeptideDB.html","title":"PeptideDB","content":"(**\n---\ntitle: PeptideDB\ncategory: Tools\ncategoryindex: 1\nindex: 3\n---\n*)\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/ProteomIQon/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n# PeptideDB\n\nMS-based shotgun proteomics estimates protein abundances using a proxy: peptides. An established method to identify acquired MS/MS spectra is the comparison of each spectrum with peptides in a reference database. \nThe PeptideDB tool helps to create peptide databases by in silico digestion given proteome information in the FASTA format and a set of parameters that allow the user to mimic conditions of their specific experiment. \nThe created database stores peptide protein relationships in a SQLite database which can then be supplied to other ProteomIQon tools.\n\n## Parameters\nThe following table gives an overview of the parameter set:\n\n| **Parameter**              | **Default Value**                                                 | **Description**                                                     |\n|----------------------------|-------------------------------------------------------------------|---------------------------------------------------------------------|\n| Name                       | \u0022YourNameHere\u0022                                                    | Name of the database                                                |\n| ParseProteinIDRegexPattern | id                                                                | Regex pattern for parsing of the protein IDs in the database        |\n| Protease                   | Protease.Trypsin                                                  | Protease used for the digestion of the proteins                     |\n| MinMissedCleavages         | 0                                                                 | Minimal amount of missed cleavages a peptide can have               |\n| MaxMissedCleavages         | 2                                                                 | Maximal amount of missed cleavages a peptide can have               |\n| MaxMass                    | 15000.                                                            | Maximal mass of a peptide in Da                                     |\n| MinPepLength               | 4                                                                 | Minimal length of a peptide                                         |\n| MaxPepLength               | 65                                                                | Maximal length of a peptide                                         |\n| IsotopicMod                | [IsotopicMod.N15]                                                 | List of isotopic modifications in the experiment                    |\n| MassMode                   | MassMode.Monoisotopi                                              | Method for mass calcluation (possibilities: Monoisotopic \u0026 Average) |\n| FixedMods                  | []                                                                | Fixed modifications of the proteins                                 |\n| VariableMods               | [Modification.Oxidation\u0027Met\u0027;Modification.Acetylation\u0027ProtNTerm\u0027] | Variable Modifications of the proteins                              |\n| VarModThreshold            | 4                                                                 | Threshold for variable modifications                                |\n\n## Parameter Generation\n\nParameters are handed to the cli tool as .json files. You can download an example file [here](https://github.com/CSBiology/ProteomIQon/blob/master/src/ProteomIQon/defaultParams/peptideDBParams.json), \nor use an F# script, which can be downloaded or run in Binder at the top of the page, to write your own parameter file:\n*)\n\n#r \u0022nuget: BioFSharp.Mz, 0.1.5-beta\u0022\n#r \u0022nuget: Newtonsoft.Json, 12.0.3\u0022\n#r \u0022nuget: ProteomIQon, 0.0.5\u0022\n\nopen BioFSharp.Mz.SearchDB\nopen Newtonsoft.Json\nopen ProteomIQon\n\nlet peptideDBParams: Dto.PeptideDBParams = \n    {\n    Name                        = \u0022Test\u0022\n    ParseProteinIDRegexPattern  = \u0022id\u0022\n    Protease                    = Protease.Trypsin\n    MinMissedCleavages          = 0\n    MaxMissedCleavages          = 2\n    MaxMass                     = 15000.0\n    MinPepLength                = 4\n    MaxPepLength                = 65\n    IsotopicMod                 = [IsotopicMod.N15]\n    MassMode                    = MassMode.Monoisotopic\n    FixedMods                   = []\n    VariableMods                = [Modification.Oxidation\u0027Met\u0027;Modification.Acetylation\u0027ProtNTerm\u0027]\n    VarModThreshold             = 4\n    }\n\nlet serialized = \n    peptideDBParams\n    |\u003E JsonConvert.SerializeObject\n\nSystem.IO.File.WriteAllText(\u0022path/to/your/params.json\u0022,serialized)\n\n(***condition:ipynb***)\n#if IPYNB\n(**\nIf you are running this tool in Binder, you can copy the output of the following codeblock and save it in a JSON file.\n*)\nserialized\n#endif // IPYNB\n\n(**\n## Executing the Tool\nTo create a peptide data base just call the tool:\n*)\n\n(**\n\tproteomiqon-peptidedb -i \u0022path/to/your/proteom.fasta\u0022 -o \u0022path/to/your/outDirectory\u0022 -p \u0022path/to/your/params.json\u0022\n*)\n\n(**\nA detailed description of the CLI arguments the tool expects can be obtained by calling the tool:\n*)\n\n(**\n\tproteomiqon-peptidedb --help\n*)"}]